import Code from "../../paragraph/Code.tsx";
import Heading from "../../paragraph/Heading.tsx";
import List from "../../paragraph/List.tsx";
import axios from "axios";
import {useMutation, useQuery, useQueryClient, UseQueryResult} from "react-query";
import id from "../../utils/Utils.tsx"
import {Button, Spin} from "antd";
import {useState} from "react";


interface User {
    id: number;
    name: string;
    email: string;
}

async function fetchUsers(): Promise<User[]> {
    console.log("Fetching data...")
    const response = await axios.get('https://jsonplaceholder.typicode.com/users');
    await new Promise((resolve) => setTimeout(resolve, 2000));
    return response.data;
}

function useUsers() {
    return useQuery<User[], Error>('users', fetchUsers);
}


function Content({ users, isLoading, error }: { users: User[] | undefined, isLoading: boolean, error: Error | null }) {
    if (isLoading) {
        return <Spin size="large" tip="Loading..." />;
    } else if (error) {
        return <p>An error occurred: {error.message}</p>;
    } else if (!users) {
        return <div>No users found</div>;
    } else {
        return (
            <>
                {users.slice(0, 3).map((user: User) => (
                    <div key={id()}>{user.name} - {user.email}</div>
                ))}
            </>
        );
    }
}


export default function ReactQuery() {
    const {data: users, isLoading, error} = useUsers();
    const [count, setCount] = useState<number>(0)
    const queryClient = useQueryClient()



    const codeExample = ``.trim()

    console.count("Rendering ReactQuery component")
    return (
        <>
            <Heading size={1}>ReactQuery</Heading>
            <List items={[
                <li key={1}>
                    <Code>ReactQuery</Code> offers a custom hook which replace the need to tinkering your solution to
                    make REST queries to some backend. Usually you would <Code>useEffect</Code> which makes this
                    standard procedure more complicated. <Code>ReactQuery</Code> also caches queries by default.
                </li>,
                <li key={id()}>
                    Let's say you fetch some data from the backend:
                    <div className={"border-2 border-ant-blue p-2"}>
                        <Content users={users} isLoading={isLoading} error={error} />
                    </div>
                </li>,
                <li key={id()}>
                    Then you get memoized state as using <Code>useEffect</Code> out of the box. E.g. this will change
                    the state of the component via <Code>useState</Code> but no fetching is done again.<br/>
                    <Button className={"bg-amber-400"} onClick={() => setCount(count => count + 1)}>
                        Counter: {count}
                    </Button>
                </li>,
                <li key={id()}>
                    Additionally we get the ability to invalidate the cache which will force to re-run the query. This
                    is useful is you e.g. saved something and then want a new list from the server which has the newest
                    results.<br/>
                    <Button className={"bg-amber-400"} onClick={() => queryClient.invalidateQueries('users')}>
                        Invalidate query 'users'
                    </Button>
                </li>
            ]}/>

        </>
    )
}
